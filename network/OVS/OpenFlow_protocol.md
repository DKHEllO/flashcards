# OpenFlow协议

## 一、Introdution

![image-20200311163917481](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200311163917481.png)

OpenFlow逻辑交换机由一个或多个流表和一个组表(执行包查找和转发)以及一个或多个连接外部控制器的OpenFlow channels组成。

匹配从第一个流表开始，并可能通过pipeline去往其他流表。流条目按照优先级顺序匹配包，优先级最高的作为每个表中第一个匹配的条目被使用，如果找到匹配的条目，则执行与特定流条目相关联的指令(参见5.5)。如果在流表中没有找到匹配项，则结果取决于table miss表项：例如，数据包可以通过OpenFlow通道转发给控制器，也可以被丢弃，或者可以继续到下一个流表。

与每个流条目相关联的指令包含actions或修改流水线处理流程。指令中包含的操作包括包转发、包修改和组表处理。流水线处理指令允许将数据包发送到后续的表中进行进一步处理，并允许**以元数据的形式在表之间交流信息**。当与匹配流项关联的指令集没有指定下一个表时，表管道处理将停止;此时，数据包通常被修改和转发。

流条目可以转发到端口。这通常是一个物理端口，但也可能是一个由交换机定义的逻辑端口，或者是一个由本规范定义的预留端口。预留端口可以指定一般的转发操作，如发送到控制器、泛洪或使用非OpenFlow方法转发，如正常的交换机内部处理逻辑(见4.5)，而交换机定义的逻辑端口可以指定链路聚合组、隧道或环回接口(见4.4)。

与流条目相关的操作也可以将包定向到一个组，该组指定了**额外的处理**。组表示洪泛操作的集合，以及更复杂的转发语义(例如多路径、快速重路由和链接聚合)。作为一般的间接层，组还允许多个流条目转发到单个标识符(例如，基于IP层转发到公共下一跳)。**这种抽象允许有效地更改跨流表项的公共输出操作**。

组表包含组表项;每个组表项包含一个操作桶列表，其特定语义依赖于组类型。一个或多个操作桶中的操作应用于发送到组表的包。

### 名词解释

- **Action**:可以将操作指定为与流条目关联的指令集的一部分，也可以指定为与组表项关联的操作桶的一部分。动作可以在Action Set中累积，也可以立即应用到包上。

- **List of Actions**：在Apply-Action指令集或packet-out消息中的流表项中的一组有序操作，并会按列表顺序立即执行(见5.7)。列表中的动作可以重复，它们的效果是累积的。

- **Set of Actions**：添加到操作集的Write-Actions指令的流条目中包含的一组操作，或按操作集顺序执行的组操作桶中包含的一组操作(请参阅5.6)。集合中的每种操作只能发生一次。

- **Action Bucket**：一组动作的集合。组表将为每个数据包选择一个或多个bucket执行。

- **Action Set**：与包相关的一组操作，这些操作是在每个表处理包时累积的，并且在指令集终止流水线处理时按指定的顺序执行。
- **Counter**：计数器是OpenFlow统计信息的主要元素，在流水线的各个特定点(如端口或流入口)进行累积。计数器通常计算通过OpenFlow元素的包和字节的数量，但是也定义了其他计数器类型。
- **Datapath**：OpenFlow逻辑交换机中直接参与流量处理和转发的组件的聚合。数据路径包括参与流表处理的流水线、组表和端口。
- **Flow** **Entry**：流表中的一个元素，用于匹配和处理数据包。它包含一组用于匹配包的匹配字段、一组用于匹配优先级的优先级、一组用于跟踪包的计数器和一组要应用的指令。
- **Flow** **Table**：流水线处理的一个阶段。它包含流条目。
- **Group**：一个动作桶的列表，以及选择一个或多个桶来应用于每个包的一些方法
- **Hybrid**：集成OpenFlow操作和普通的以太网交换操作
- **Instruction**:指令被附加到流条目上，并描述包匹配流条目时发生的OpenFlow操作。一条指令可以修改流水线处理，例如将包指向另一个流表，或者包含一组要添加到操作集的操作，或者包含一组要立即应用到包的操作。
- **Instruction Set**：附加到流表中的流表项上的一组指令。
- **Match Field**：流入口的一部分，与包相匹配。匹配字段可以匹配各种包头字段(见7.2.3.8)、包入口端口、元数据值和其他管道字段(见7.2.3.9)。匹配字段可以是通配符(匹配任何值)，在某些情况下是位掩码(匹配位的子集)。
- **Metadata**：一种可屏蔽的寄存器，用来将信息从一个表传送到下一个表。
- **Message**：通过OpenFlow连接发送的OpenFlow协议单元。可以是请求、应答、控制消息或状态事件。
- **Meter**：一种可以测量和控制数据包速率的开关元件。meter设置了一个meter band如果包速率或字节速率超过了预定义的阈值(见5.11)，则将触发一个行为。如果该行为丢弃数据包，就称为速率限制器。
- **Pipeline**：在OpenFlow交换机中提供匹配、转发和包修改的一组流表链。
- **Pipeline fields**：在pipeline处理过程中附加到包上的一组值，它们不是包头字段。包括入口端口、元数据值、隧道id值等。
- **Queue**：根据包在输出端口上的优先级来调度包，以提供QOS保障。
- **Tag**：可以通过推送和弹出操作从包中插入或删除的标头。
- **Outermost Tag**：最接近包开头的标记。

## 二、OpenFlow Ports

本节描述OpenFlow端口抽象和OpenFlow支持的各种类型的OpenFlow端口。

#### OpenFlow Ports

OpenFlow报文在入端口接收，并由OpenFlow流水线(见5.1)处理，后者可以将它们转发到输出端口。入端口可以用来匹配报文。OpenFlow流水线可以决定使用输出动作将报文从出端口发出去，这些操作定义了数据包如何返回到网络。

OpenFlow逻辑端口是不直接对应于交换机硬件接口的交换机定义的端口。逻辑端口是更高层次的抽象，可以在交换机中使用非openflow方法定义(例如链路聚合组、隧道、环回接口)。

逻辑端口处理机制依赖于实现，并且必须对OpenFlow处理透明，并且这些端口必须与OpenFlow处理(如OpenFlow物理端口)交互。

物理端口和逻辑端口之间的惟一区别是，与逻辑端口相关联的包可能有一个名为Tunnel-ID的额外pipeline字段并且当在逻辑端口上接收到的包被发送到控制器时，它的逻辑端口和底层物理端口都被报告给控制器。

#### Reserved Ports

OpenFlow保留端口是由这个规范定义的。它们指定了一般的转发操作，如发送到控制器、泛洪或使用非openflow方法(如正常包处理流程)进行转发。

不需要交换机来支持所有的保留端口，只需要下面标记为“required”的端口即可。

- **Required: ALL:**表示交换机可以用来转发特定数据包的所有端口。只能用作输出端口。在这种情况下，包的副本将在所有标准端口上启动出端口处理，不包括包的入口端口和配置为ppc_no_fwd的端口。
- **Required: CONTROLLER**：代表了controller的控制通道；可以用作输入端口，也可以用作输出端口。当用作输出端口时，将包封装在packet-in消息中，并使用OpenFlow交换协议发送它。当用作入口端口时，它标识来自控制器的数据包。
- **Required: TABLE**：表示OpenFlow流水线的开始。此端口仅在packet-out消息中的的操作列表中的output操作中有效，并将包提交给第一个流表，以便可以通过正常的OpenFlow流水线处理该包
- **Required: IN PORT**：表示数据包进入端口。只能作为一个输出端口使用，通过它的入口发送数据包。
- **Required: ANY:**当没有指定端口时，在一些OpenFlow请求中使用的特殊值。一些OpenFlow请求包含对特定端口的引用，该请求只应用于该端口。在这些请求中使用ANY作为端口号，允许该请求实例应用于任何和所有端口。既不能用作输入端口，也不能用作输出端口
- **Required: UNSET**：用于指定未在Action-Set中设置输出端口的特殊值。仅在尝试使用OXM_OF_ACTSET_OUTPUT匹配字段匹配操作集中的输出端口时使用。既不能用作输入端口，也不能用作输出端口。
- **Optional: LOCAL**：表示交换机的本地网络堆栈及其管理堆栈。可以用作输入端口，也可以用作输出端口。本地端口允许远程实体通过OpenFlow网络与交换机及其网络服务交互，而不是通过单独的控制网络。通过适当的一组流条目，**可以使用它来实现带内控制器连接**。
- **Optional**: **NORMAL**:表示不经过流水线正常进行二三层转发。
- **Optional: FLOOD:**表示采用传统的非OpenFlow流水线的洪泛方法。通常会将数据包发送出所有的标准端口，但不会发送到入口端口，也不会发送到OFPPS_BLOCKED状态下的端口。交换机也可以使用包VLAN ID或其他标准来选择要用于洪泛的端口。

#### Port changes

添加、修改或删除端口不会更改流表的内容，特别是引用这些端口的流条目不会被修改或删除(流条目可以通过匹配或动作引用端口)。转发到不存在端口的包将被丢弃(见5.6)。同样，端口的添加、修改和删除也不会改变组表的内容，但是某些组的行为可能会通过存活检查而改变(见6.7)。

如果一个端口被删除，并且它的端口号稍后被另一个物理或逻辑端口重用，那么仍然引用该端口号的任何存在的流条目或组条目都可能被有效地重定向到一个新端口，这可能会产生不好的结果。**因此，当一个端口被删除时，如果需要，控制器将清理引用该端口的任何流条目或组条目。**

#### Port recirculation（环？）

逻辑端口可用于在OpenFlow交换机中插入网络服务或复杂的处理(见4.4)。大多数情况下，发送到逻辑端口的包永远不会返回到相同的OpenFlow交换机，它们要么被逻辑端口使用，要么最终通过物理端口发送。在某些情况下，发送到逻辑端口的数据包在逻辑端口处理之后会再回到OpenFlow交换机。（loopback？）

最简单的再循环是在逻辑端口上发送的包通过相同的逻辑端口返回到交换机。这可以用于环回或单向包处理。

隧道id字段和其他一些与包相关的pipeline字段可以通过再循环保留，当返回到交换机时可以进行匹配，保留的管道字段通过端口匹配字段属性表示。If a pipeline field is present in both the OFPPDPT_PIPELINE_OUTPUT property of the output port and the OFPPDPT_PIPELINE_INPUT property of the return port, then this pipeline field is preserved with the packet (its value must remain the same).

## 三、OpenFlow Tables

![image-20200312015619158](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200312015619158.png)

#### Pipeline Processing

OpenFlow-hybrid交换机支持OpenFlow操作和普通以太网交换操作，即传统的L2以太网交换、VLAN隔离、L3路由(IPv4路由、IPv6路由……)ACL和QoS处理。这些交换机应该应该在OpenFlow之外提供一个分类机制将流量路由到OpenFlow流水线或常规交换机的流水线。例如，交换机可以使用包的VLAN标记或输入端口来决定是使用这个pipeline还是另一个pipeline来处理包，或者它可以将所有包都指向OpenFlow流水线。这种分类机制超出了本规范的范围。一个OpenFlow-hybrid交换机也可以允许一个数据包从OpenFlow流水线到正常流水线通过NORMAL和FLOOD预留端口。

OpenFlow流水线定义了包如何与这些流表交互(参见图2)。OpenFlow交换机至少需要有一个入口流表，并且可以选择有更多的流表。流水线的处理发生在两个阶段，入向处理和出向处理。分离的两个阶段是由第一个出口表(见7.3.2)表示,所有表的number低于第一个exgress table必须被当作ingress table使用,并且没有表number高于或等于第一个exgress table也可以作为ingress table。

如果入向处理的结果是将包转发到输出端口，OpenFlow交换机可以在该输出端口的上下文中执行出向处理。出向处理是可选的，一个交换机可能不支持任何出口表，也可能没有被配置成使用它们。如果没有有效的出口表被配置为第一个出口表(参见(7.3.2)，数据包必须由出端口处理，多数情况下数据包由交换机转发出去。如果一个有效的出口表被配置为第一个出口表(见7.3.2)，则数据包必须与流条目相匹配

流条目只能将包指向大于其自身流表号的流表，换句话说，流水线处理只能前进，不能后退。

OpenFlow管道和各种OpenFlow操作按照为该包类型定义的规范处理特定类型的包，除非当前规范或OpenFlow配置以其他方式指定。例如，Open-Flow使用的以太网报头定义必须符合IEEE规范，OpenFlow使用的TCP/IP报头定义必须符合RFC规范。

#### Pipeline Consistency

OpenFlow流水线是一个抽象，它映射到交换机的实际硬件。即使OpenFlow交换机没有虚拟化，硬件通常也不会与OpenFlow管道对应，例如，如果流表只支持以太网包，那么非以太网包就必须映射到以太网。在另一个例子中，一些交换机可能在一些内部元数据中携带VLAN信息，而对于OpenFlow流水线，它在逻辑上是包的一部分。

一些OpenFlow交换机可能定义实现复杂封装的逻辑端口，这些封装广泛地修改了包头。其结果是，链路上或硬件上的包可能在OpenFlow流水线中被不同地映射。然而，OpenFlow流水线期望到硬件的映射是一致的，并且OpenFlow流水线的行为一致

#### Flow Tables and flow entries

![image-20200316235331399](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200316235331399.png)

- **cookie**：控制器选择的不透明数据值。可由控制器用于过滤受流量统计、流量修改和流量删除请求影响的流项。处理数据包时不使用。
- **flags**：flags改变了流条目的管理方式，例如pff_send_flow_rem标志触发流表项被删除的消息。

流表条目由其匹配字段和优先级标识:匹配字段和优先级一起标识特定流表中的唯一流条目。流表项可以匹配所有字段并且优先级为0的被称为table miss流表项(参见5.4)。

`set-field`操作可以指定重写一些包头信息。每个流表可能不支持本规范定义的每个匹配字段、每个指令、每个操作或每个`set-field`操作，交换机的不同流表可能不支持相同的子集。表特性请求可以使控制器能够发现每个表支持什么。

#### Matching

除了包头之外，还可以对入口端口、元数据字段和其他管道字段执行匹配。元数据可用于在交换机中的表之间传递信息。

![image-20200317101520041](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317101520041.png)

报头字段和pipeline字段表示当前状态的包，如果使用Apply-Actions指令应用于前一个表中的操作更改了报头或pipeline字段，这些更改将反映在报头字段和pipeline字段中。

如果匹配字段存在且不包含掩码，则匹配字段将匹配包中相应的包头字段或pipeline字段(如果该字段具有相同的值)。如果交换机支持特定匹配字段上的任意位掩码，那么这些掩码可以更精确地指定匹配，如果匹配字段对掩码中设置的位具有相同的值，则匹配字段

该包将根据流表中的流条目进行匹配，并且必须只选择与该包匹配的**优先级最高**的流条目。如果有多个具有相同最高优先级的匹配流条目，所选的流条目显式地未定义。这种场景仅当控制器写入器在流修改消息中从未设置OFPFF_CHECK_OVERLAP位和添加重叠的流表项时出现。

如果交换机配置包含OFPC_FRAG_REASM标志。则在进行流水线处理之前必须重新组装IP片段。

这个版本的规范没有定义当交换机在OpenFlow端口(见4.1)或在包输出消息中接收到畸形或损坏的包时所期望的行为

#### Table-miss

table-miss流条目指定如何处理流表中与其他流条目不匹配的包(参见5.1)，例如，可以将包发送到控制器，将包丢弃或将包直接发送到后续表。

table-miss由它的匹配和优先级来标识，它匹配所有字段并具有最低优先级(0)。如果表丢失的流条目不存在，默认情况下，流条目不匹配的包将被丢弃。交换机配置(例如使用OpenFlow配置协议)可以覆盖此默认设置并指定另一种行为。如果流表支持使用最低优先级(0)的流条目，并且只匹配某些字段，这并不是table-miss字段。使用这种流表在table-miss不存在的时候是有意义的，因为如果存在table-miss，它们就会重叠，那么匹配就没有定义。出于这个原因，建议控制器不要创建使用最低优先级(0)的非table-miss流条目。

**一个优先级的流表只能有一条吗**？

#### Instructions

![image-20200317103928205](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317103928205.png)

- **Apply-Actions action(s):**立即应用特定的操作，而不对操作集进行任何更改。此指令可用于修改两个表之间的数据包或执行同一类型的多个操作。操作被指定为一个操作列表(参见5.7)。
- **Clear-Actions:**立即清除操作集中的所有操作。仅对table-miss流条目需要此指令的支持(参见5.4)，对其他流条目可选。
- **Write-Actions action(s):**将指定的操作集合并到当前操作集(见5.6)。如果当前集合中存在给定类型的操作，则覆盖它，否则添加它。如果当前集合中存在具有给定字段类型的`set-field`操作，则覆盖它，否则添加它。所有流表都必须支持此指令。
- **Write-Metadata metadata / mask:**将可掩码的元数据值写入元数据字段。掩码指定应该修改元数据寄存器的哪些位(i.e. new metadata = old metadata & ˜mask | value & mask)。
- **Stat-Trigger stat thresholds**：如果某些流统计信息超过某个统计阈值，则向控制器生成一个事件。
- **Goto-Table next-table-id:**指示流水线处理中的下一个表。表id必须大于当前表id。除了最后一个流表（**如何判断是最后一个流表**？**Instructions中不包含Goto-Table指令**），所有流表都必须支持这条指令，只有一个流表的OpenFlow交换机不需要实现这条指令。流水线的最后一个表的流表项不能包含这条指令(见5.1)。

与流条目关联的指令集最多包含每种类型的**一条指令**。`experimenter`指令由`experimenter` `id`和`experimenter`类型标识，因此，对于`experimenter id`和`experimenter`类型的每个组合，指令集最多可以包含一个`experimenter`指令。集合中的指令按上述列表中指定的顺序执行。在实践中，惟一的约束是在`Write-Actions`指令之前执行`Clear-Actions`指令，在`Write-Metadata`之前执行`Apply-Actions`指令，最后执行`Goto-Table`指令。

如果交换机无法执行与流表项关联的指令或部分指令，则必须拒绝该流表项。在这种情况下，交换机必须返回与问题相关的错误消息。

#### Action Set

动作集与每个包相关联。此集合默认为空。流条目可以使用`Write-Action`指令或与特定匹配关联的`Clear-Action`指令来修改操作集。动作集在流表之间传送。**当流条目的指令集不包含Goto-Table指令时**，流水线处理将停止，并执行包的操作集中的操作(参见图3)。

操作集最多包含每种类型的一个操作。`set-field`动作是由它们的目标字段类型来标识的，因此，对于每个字段类型，动作集最多包含一个`set-field`动作(可以设置多个字段，但每个字段只能设置一次)。由于竞争条件，动作集中的`copy-field`的效果是未定义的，因此不鼓励其实现。当在操作集中添加特定类型的操作时，如果存在相同类型的操作，则后面的操作将**覆盖它**。如果需要多个相同类型的动作，例如:添加多个MPLS标签或弹出多个MPLS标签时，应使用Apply-Actions指令。

用于出口处理的操作集有一个限制，即不能将`output action`和`group action`添加到`egress`操作集。用于出口处理的操作集在出口处理开始时初始化，**并带有当前输出端口的输出操作，而用于入口处理的操作集则开始为空。**

操作集中的操作按照下面指定的顺序应用，而不考虑它们被添加到集合中的顺序。如果一个操作集包含一个组操作，那么该组的操作桶中的操作也将按照下面指定的顺序应用。

- **copy TTL inwards**：将TTL复制到包里
- **pop**：将所有标签弹出动作应用到包上
- **push-MPLS**：对数据包打上MPLS标签
- **push-PBB**：对数据包打上PBB标签
- **push-VLAN**：对数据包打VLAN标签
- **copy TTL outwards**：复制数据包当前的TTL
- **decrement TTL**：对数据包执行TLL减操作
- **set**：所有的set-field的操作
- **qos**: 应用所有的QoS动作，如meter和设置队列
- **group**：如果指定了组操作，则按照此列表指定的顺序执行组bucket的操作
- **output**：如果没有指定组操作，则在输出操作指定的端口上转发包

操作集中的输出操作最后执行。如果在操作集中同时指定了输出操作和组操作，**则忽略输出操作，组操作优先。**如果在操作集中没有指定输出操作和组操作，则数据包将被丢弃。如果没有指定组操作，并且输出操作引用了一个不存在的端口，则数据包将被丢弃。如果交换机支持组的执行，则**组的执行是递归的**;组桶可以指定另一个组，在这种情况下，操作的执行将遍历组配置指定的所有组。

在`ingress`和`egress`输出动作的处理方式是不同的(见5.1)。当`ingress`动作集包含一个`output`动作或一个`group`动作将包转送至一个端口时，包必须在该端口上开始执行egress处理。当`exgress`操作集包含一个输出操作时，包必须退出出向处理流程，并且必须由端口处理，并且在大多数情况下，它是由交换机转发出去的。

#### List of Actions

`Apply-Actions`指令和`Packet-out`消息包含一个操作列表。操作列表的语义与OpenFlow 1.0规范相同。操作列表中的操作按照列表指定的顺序执行，并立即应用到包中。

操作列表的执行从列表中的第一个操作开始，每个操作依次在包上执行。如果操作列表包含两个Push-VLAN操作，**那么这些操作的效果是累积的**，两个VLAN头被添加到包中。

如果操作列表包含一个输出操作，则以当前状态将包的一个克隆(副本)转发到所需的端口，并在那里开始出口处理。如果输出操作引用了所有的保留端口，包的一个克隆就开始对每个相关端口进行出口处理(见4.5)。如果输出操作引用一个不存在的端口，则删除该包的克隆。如果操作列表包含一个组操作，则相关组桶将处理当前状态的包的克隆(请参阅5.10)。将pipeline字段与包进行克隆。任何修改了一个克隆的包或其pipeline 字段生成的输出或一组行动,例如改变一个头字段或一群斗的元数据字段或一个出口表,仅适用于克隆,不适用于原包或其他克隆。

在Apply-Actions指令中的操作列表执行之后，流水线操作将继续在修改后的包上执行(参见5.1)。包的动作集在执行动作列表时不变。

**如何在未匹配的情况下使用`Apply-Actions`执行`List of Actions`？见`Figure 4`**

#### Actions

- **Output port_no**:输出操作将数据包转发到指定的OpenFlow端口(见4.1)开始出向处理。OpenFlow交换机必须支持转发到物理端口、交换机定义的逻辑端口和所需的保留端口(见4.5)。

- **Group group_id**：通过指定的组处理数据包(见5.10)。准确的解释取决于组类型。

- **Drop**：丢弃报文。这个结果可能来自流水线处理中的空指令集或空操作桶(见5.6)，或者在执行`Clear-Actions`之后。

- **Set-Queue queue_id**:设置队列id。当使用输出操作将包转发到端口时，队列id确定连接到该端口的哪个队列用于调度和转发包。转发行为由队列的配置决定，用于提供基本的服务质量(QoS)支持。

- **Meter meter_id**:直接将包传送到指定的meter表。meter表处理的的结果可能会把包丢弃（取决于meter表的设置和状态）。如果交换机支持meters，这个动作必须要在`list of actions`中首先支持，用于向后兼容该规范的早期版本。

- **Push-Tag/Pop-Tag ethertype**：交换机需要支持推/弹出标签的功能，如表2所示。为了帮助与现有网络的集成，我们建议push/pop VLAN标签的的能力需要支持。

  新推送的标签应该总是作为最外层的标签插入到该标签的最外层有效位置(见7.2.6.6)。当多个推送操作被添加到包的操作集中时，它们按照操作集规则定义的顺序应用到包上，首先是MPLS，然后是PBB，然后是VLAN(见5.6)。当多个push操作包含在一个操作列表中时，它们按列表顺序应用于包。

  ![image-20200317115154674](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317115154674.png)

- **Set-Field field type value**：各种`Set-Field`动作由它们的字段类型标识，并修改包中相应头字段的值(见7.2.3.7)。虽然不是严格要求的，但是使用集合字段操作重写各种头字段的支持极大地增加了OpenFlow实现的有用性。为了帮助与现有网络的整合，我们建议这样做支持VLAN修改操作。`Set-Field`操作应该总是应用于最外层的可能的标题(例如，“设置VLAN ID”操作总是设置最外层VLAN标记的ID)，除非字段类型另行指定。

- **Copy-Field src field type dst field type**:`Copy-Field`操作可以在任何头字段或管道字段之间复制数据。它通常用于将数据从报头字段复制到`packet register pipeline`字段，或从`packet register pipeline`字段复制到报头字段，在某些情况下，还用于从报头字段复制到另一个报头字段。开关可能不支持标题字段或管道字段之间的所有副本组合。

- **Change-TTL ttl**:各种`Change-ttl`操作修改`IPv4 TTL`, IPv6跳数限制或`MPLS TTL`。虽然不是严格要求的，但是表3中显示的操作极大地增加了OpenFlow实现实现路由功能的可用性。`Change-ttl`操作应该**始终**应用于最外层的报头。

  ![image-20200317115913555](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317115913555.png)

  OpenFlow交换机检查IP TTL或MPLS TTL无效的数据包，并拒绝它们。检查无效的TTL不需要对每个包都做，但是必须在每次将减量TTL操作应用到包时至少做一次。交换机的异步配置的改变(见6.1.1)可以通过`packet-in`消息(见6.1.2)通过控制通道向控制器发送TTL无效的数据包。

##### Default values for fields on push

当通过推送操作添加新标签时(见5.8)，推送操作本身并没有为这个tag的header字段部分指定大部分的值。其中大多数是通过“set-field”动作单独设置的。这些header字段在push操作期间初始化的方式取决于这些字段是否被定义为OpenFlow匹配字段(见7.2.3.7)和包的状态。表4列出了标记推送操作的头字段部分，并将其定义为OpenFlow匹配字段。

![image-20200317120414379](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317120414379.png)

![image-20200317121138263](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317121138263.png)

​                                                                                  VLAN 帧格式

当执行一个push操作时，对于表4中添加的报头部分中指定的所有字段，包的现有外部报头中对应字段的值应该复制到新字段中。如果包中不存在相应的外部头字段，则应将新字段设置为0。

没有定义为OpenFlow匹配字段的报头字段应该初始化为适当的协议值:这些报头字段应该按照控制该字段的规范进行设置，同时考虑到包报头和交换机配置。例如，在大多数情况下，VLAN报头中的DEI位应该设置为0。

新报头中的字段可以通过在push操作之后为适当的字段指定“set-field”操作来覆盖。动作集中动作的执行顺序是为了方便这个过程而设计的(见5.6)。

#### Counters

每个流表、流入口、端口、队列、组、组桶、meter和meter band都有计数器。兼容openflow的计数器可以在软件中实现，并由范围更有限的轮询硬件计数器维护。Table5包含了OpenFlow规范定义的计数器。交换机不需要支持所有uration的计数器，只需要那些在表5中标记为“required”的计数器。

Durations是指在交换机中下发的流入口、端口、组、队列或meter的持续时间，并且必须以秒的精度跟踪。`Receive Errors`字段是表5中定义的所有接收和冲突错误以及表中未调用的其他错误的总和。

OpenFlow对象的包相关计数器必须计数使用该对象的每个包，即使该对象对包没有影响，或者包最终被丢弃或发送到控制器。例如，交换机应维护以下包相关的计数器:

- a flow entry with only a goto-table instruction and without actions
- a group outputing to a non-existent port
- a flow entry triggering a TTL exception
- a port which is down

计数器是无符号的，并且没有溢出指示器。计数器必须在翻转之前使用为计数器定义的完整位范围，例如，如果计数器定义为64位，则不能只使用较低的32位。

![image-20200317154729698](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317154729698.png)

#### Group Table

组表由组条目组成。流条目指向组的能力使OpenFlow能够表示其他转发方法。

![image-20200317155106397](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317155106397.png)

每个组条目(见表6)由其组标识符标识，并包含:

- **group identifier**：一个32位无符号整数，惟一地标识OpenFlow交换机上的组表。
- **group type**：确定组语义
- **counters**：当有包被处理时更新
- **action buckets**：一个有序的操作桶列表，其中每个操作桶包含一组要执行的操作和相关的参数。bucket中的操作总是作为action set应用。

除了总是有一个桶的`indirect`类型组之外，组条目可以由零个或多个桶组成。没有桶的组会有效地丢弃数据包。桶通常包含修改包的操作和将包转发到端口的输出操作。如果交换机支持组链(见6.7)，则bucket还可以包含调用另一个组的组操作，在这种情况下，包处理将在调用的组中继续。没有操作的桶是有效的，没有输出或组操作的桶会有效地删除与该桶关联的包的克隆

##### Group Types

- **indirect**：执行该组中定义的bucket。这个组只支持一个桶。允许多个流条目或组指向公共组标识符，支持更快、更有效的聚合**(e.g. next hops for IP forwarding)**。这个组类型实际上与只有一个bucket的组相同。这个类型是最简单的组表类型，因此交换机支持该类型的流表数明显大于其他类型
- **all**：执行组中的所有bucket。此组用于多播或广播转发。**对每个桶有效地克隆数据包;组的每个桶处理一个包**。如果一个桶显式地将一个包从入口端口发出，这个包的克隆就会被丢弃。如果控制器writer希望将包从入端口发出去，则该组必须包含一个额外的bucket，该bucket将包含一个输出操作将包发送到`OFPP_IN_PORT`保留端口。
- **select**：在组中执行一个bucket。包将会由交换机的**选择算法**（类似于哈希算法）选择的桶进行处理（例如：例如，哈希一些用户配置的元组或简单的循环）。所有选择算法的配置和状态都是向外部OpenFlow协议开放的。选择算法应该实现均匀的负载共享，并且可以根据桶的权重进行选择。**当在一个select组的bucket中指定的端口down时，交换机可能会将bucket的选择限制在剩余存活的集合中(那些将转发操作到正常端口的集合)，而不是丢弃发送到该端口的包。**这种行为可以减少由于链路中断而断开的连接。
- **fast failover**：执行第一个存活的bucket。每个动作桶都与控制其活性的指定端口和/或组相关联。桶按组定义的顺序进行评估，并选择与活动端口/组关联的第一个桶。这个组类型使交换机能够更改转发，而不需要控制器进行决策。如果没有桶是存活的，则丢弃包。这个组类型必须实现一个`liveness mechanism`

##### Group Liveness Monitoring

`fast failover`类型需要进行存活监控，以确定要执行的特定bucket。

组bucket可以显式地监视一个端口或另一个组的活动。判定是否存活的规则包括:

- 如果一个端口存在于`datapath`中，并且在其端口状态中设置了OFPPS_LIVE标志，则认为该端口是活动的。端口活性可以由交换机的OpenFlow部分之外的代码来管理，定义在OpenFlow规范之外，**如生成树或KeepAlive机制**。这几种情况下端口不能被视为存活(`OFPPS_LIVE`标志必须被设置)，如果交换机上的存活检测机制被使能了并且认为那个OpenFlow端口没有存活、如果端口`OFPPC_PORT_DOWN`位被置位表明该端口状态为down、如果端口状态位`OFPPS_LINK_DOWN`被置位也表示该链路状态为down
- 如果`watch_port`不是`OFPP_ANY`且所观察的端口是活动的，或者如果`watch_group`不是`OFPG_ANY`且所观察的组是活动的，则bucket将被视为活动的。换句话说，如果`watch_port`是`OFPP_ANY`或所监视的端口不是活动的，而`watch_group`是`OFPG_ANY`或所监视的组不是活动的，那么bucket就被认为是不活动的。
- **如果一个组的bucket中至少有一个是活动的，则该组被认为是活动的。**

控制器可以通过监控各个端口的状态来推断组的活性状态。

#### Meter Table

一个meter表由meter表条目组成，定义每条流的的meters。逐流meters可以通过OpenFlow实现限速、简单的QoS操作通过约束一组流到指定的带宽。逐流meters也可以通过OpenFLow去实现更复杂的Qos策略操作，例如基于DSCP的计量，它可以根据数据包的速率将一组数据包分成多个类别。Meter表完全独立于每个端口队列，然而，在许多情况下，这两个特性可以结合起来实现复杂的工作，以保护QoS框架，如DiffServ。

Meter表测量分配给它的包的速率并且去控制这些包的速率。Meter表直接和流表项关联(而不是和端口的队列)。如果交换机支持它，任何流表项都可以在一个动作列表中指定一个meter动作(见5.8):该meter表测量并控制它所连接到的所有流表项的聚合速率。

![image-20200317165440653](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317165440653.png)

每个meter表项(见表7)由其表项标识符标识，并包含:

- **meter identifier**：一个32位无符号整数，唯一地标识meter表

- **meter bands**：一个无序的meter band列表，其中每个meter band指定band的速率和处理数据包的方式
- **counters**：当数据包被meter表处理时更新

同一流表中的不同流表项可以使用相同的meter，不同的meter或根本没有meter。通过在流表中使用不同的meter表，可以独立地对不相交的流量表进行控制（metered）。当在连续的流表中使用meter表时，数据包可以通过多个meter表，在每个流表中，匹配的流表项可以将其指向一个meter表。使用多个meter表的另一种方法是，如果交换机支持它，则为每个流表项使用多个meter动作。这可以用于执行分层计量，其中首先独立地计量各种流量集，然后加和。

![image-20200317170145121](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317170145121.png)

**没有理解**

##### Meter Bands

每个meter表可以有一个或多个band。这些band用于定义包上的meter表在不同的测量速率范围内的行为。meter表测量速率是使用来自所有流向该meter的数据包的所有流表项的数据包计数器来计算的。对于每个数据包，meter表根据测量速率、band速率值和meter配置，选择一个band。一旦选择了band，meter表就将该band指定的处理应用到包上。一个数据包只被一个meter表中的一个band处理。每个meter band指定该band的目标速率，如果超过该速率，则执行相关操作。默认的band总是包含在meter表中，不能设置，**它等价于一个目标速率为0的band**，它什么都不做，只是让包通过而不做任何事情。

![image-20200317171348497](https://github.com/DKHEllO/flashcards/blob/develop/image/image-20200317171348497.png)

- **band type**:定义如何处理数据包

- **rate**：该band的目标速率——由meter表用来选择band，通常是band可以应用的最低速率
- **burst**：定义meter band的测速的粒度？突发？
- **counters:**meter band处理数据包时更新
- **type specific arguments**：一些band类型的可选参数

band type定义

- **drop**:丢弃(丢弃)数据包。可用于定义速率限制band。
- **dscp remark**：提高数据包的IP报头中DSCP字段的丢弃优先级。可以用来定义一个简单的DiffServ策略器。

band选择过程，包括测量速率的计算，是特定于实现的，而且该规范没有指定每个单独的数据包如何映射到每个band。按**目标速率的递增**对meter band进行排序，默认band为0，第一个可配置band为1。band选择过程的结果必须遵守以下所有约束条件:

- 一个包只由一个meter band处理。
- 包只有再测量速率超过band设置的速率时，才必须由一个band处理。
- 对于正在处理分组的任何band，较低级别的所有band所处理的流量必须等于设置的速率。例如，如果由第一个可配置的band处理数据包，则默认band处理的流量必须等于它设置的速率。

一个简化的模型是，对于每一个数据包，meter表采用的是比当前测量速率低的设置速率最高的band。

在实践中，**对于短时间窗口，由于包粒度、速率度量近似值和各种实现约束，meter表可能不完全遵守这些约束（CPU及其它硬件无法保证计数器的精度来应对短时间的突发）**，因此这只描述了长期行为。**测量速率的计算通常使用令牌桶或滑动窗口来完成**。特别是使用令牌桶时，**短的突发可以暂时超过一个band目标速率，而不会触发该频带。burst参数定义了band的粒度**:对于长度超过该值的突发，实际速率与band目标速率的比较必须是准确的，而对于较短的突发可能不准确。

#### Ingress and egress processing differences

